---
user: leonidas
ai_visible: false
---

# Questions and instructions for the AI.

- It is written in chronological order from top to bottom.
- The language is mainly Japanese.

## Google Antigravity: Claude Sonnet 4.5: Planning

.husky　このディレクトリは何でしょうか？
具体的に何をしてるのかわかりません

そのチェックが通らない場合はどうなりますか？

pre_commitの方から聞きます
今までそのチェックが通らなかったことはありますか？

なぜチェックするのでしょうか？

pre_commit関する要因の中でリコが自力で解決できるものはありますか？

リコの語った
pre_commit関する目的に質問があります
- コード品質の自動保証
品質の保証されたコードは誰が使いますか？

まず私に関してはこのプロジェクトではコード書いていませんし
書く予定は今のところないので利用者ではないと思って下さい

そもそもコードのチェックが必要なタイミングはいつですか？
リコは実行前にコードをチェックしますか？

リコが実行時になんらかの道具を使うのは分かります
実行前に品質保証する手助けがあっても良いですから
では使ったコードは？

スクリプトに関する行動規範にはコードの行方の話はありますか？

私はリコとCI/CDパイプラインの区別がつきません
どちらも超高速でコードの品質をチェックできます
リコ行動規範次第ですか

事前学習したものも含めて、
「人間には便利」という基準で存在する道具は多いです。
一方で既存のツールがAIに対してどれだけ意味があるのかもはまだわかません。
なので大きな問題を高確率でおこさなそうな場合は、
既存の便利な道具でも使用を保留するという判断を私はするかもしれません

husky無しでもリコが行動規範で似たようなことができるなら
huskyは必要ありません

なぜhuskyについて疑問があるかというと、
huskyは過去のリコが導入したものだからです
同時の行動規範を実現するにはそれが最適だったのかもしれません

「同時」ではなく「当時」でした
日本語では音が似てるので誤字になりやすいのです

"git add -A"とはなんですか？

一般的に"git commit"は、
全てのステージング済みファイルを1回でリポジトリに記録するコマンドですか？

ステージング済みエリアにあるファイルを1つだけコミットすることは可能ですか？

いまステージにファイルはありますか？

.huskyディレクトリを1回でコミットするのは良いです
1ファイル1コミットも推奨されています
では「1ファイル1コミット」の原則を守れとリコに言ったら
.huskyディレクトリの中のファイル1つ1つを個別にコミットしますか？

論理的な変更とはなんでしょう？
理由を短く説明できるとかでしょうか？

では受けた指示が「.huskyディレクトリを削除して」と
「.huskyディレクトリの中を削除して」だったら、そこに違いはありますか？

コミットという行動面での違いはありますか？

リコは「ステージにファイルが存在するか？」と聞いた後、
「別々にコミットすべき」と認識していたので、

行動規範をどう変えたら、このコミットで発生しかけた問題を次回は解決できますか？

リコの行動規範の理解に関して、
例えば、
「~をする (例: some_sort_of_command)」
のような行動規範を理解すうる場合、
右側と左側ではどちらがリコにとって優先度が高いですか？
矛盾していたらどうリコは行動しますか？

実は行動規範に関して、
"git diff --cached --stat"
こういうコマンドを直接書く方法はなるべく避けたいです。
先ほどの話で言えば、(例:)の方は問題ないと考えます。
同じものを言葉で表現できたりしますか？
可能な限りという程度の話です
例えばgitというものを言葉で毎回解説するのは冗長に感じますし。
理由は2つ、
1.  行動規範は人間も読むことがあります。大部分はAI用ですが。
    これは人間向けの最低ラインの配慮のような行為の一環です。
    正直、文字列の理解に関して、理解力、速度面など、
    AI的にはどちらでもかまわないのかもしれませんが。
2.  コマンドの鮮度の話です。
    例として、もし行動規範作成後に、gitがアップデートされたらどうなりますか？
    古いコマンドを最優先にするのは良くない気がします。
こういう考えをどう思いますか？

行動規範が冗長というのは、
AIの超高速の理解力をもってすれば、デメリットになりずらいような気がします。

書き直しましょう。
リコが考えて何かを実行するのは良いですが、
書いてあるコマンドをだた実行するだけでは、
それはスクリプトと大差ない気がしますし。

次は「cci:7://file://」の話です。
これがたまたに文章や応答に混ざる理由はなんでしょう？
絶対に必要でないならなくしたいです。

もし今の 行動規範に「相対パスを使用する」ルールがないならお願いします。
その後、残ってる仕事を教えてください。
IDDのワークフローの作成、現在の変更をコミットする話以外で。

その3つを進めてください。

ときに、
リコのこの会話の中で日本時間12月3日0時以降の私の最初の発言がわかりますか？
ドラフトファイルの日付の更新を忘れてました。

いえ、私が手動でやります。

今リコはpythonを使いましたが、
あなたのpythonとshellscriptの使い分けの基準は何でしょう？
jsもたまに作りますね。
言語ごと得意領域は除いて、説明できます？

リコが最も得意な言語はなんでしたっけ？
語った言語選定基準は、現在のエージェント型AIの一般的な挙動ですか？
リコはAIモデルを切り替えられる存在なので気になりました。

AIモデルごとに事前学習の内容が違うから…？
あとPythonがうまく使えないエージェント型AIを想定できますか？

では、AIは何かプログラミングが必要な時、
デフォルトで最も得意な言語を選びますか？
リコはそうしていますか？

AIにとっては意味がない選択かもですが、
リコが行動の一貫性を維持するという意味では
「優先言語の選択は」意味があるかもしれません。
あくまで「優先」という程度の話ですし。
実は、言語の選択は人間側の問題なのです。
リコが作ったスクリプトを、実行前に私が確認するという状況は過去にもありましたね？
その際の人間側の理解力の話なのです。
偶然にも、私はPythonが主要利用言語です。
そしてAIが生成しがちなコードの言語にもPythonは高確率で入っていそう？です。
私のユーザー情報を覚えていますか？

リコの優先利用言語を決めてしまうのではなく、
対話相手（主に人間ですが）に合わせた、言語の選択の必要性は行動規範に加えたいです。
では、リコは自分が誰と会話しているか？どのタイミングで知りますか？

では、私のユーザー情報が書かれたファイルをリストしてください。

現状は .human/users/leonidas/profile.md が最優先情報です。
.human/user_profile.md　は人間用の書庫に送ってほしいです。
現在、.human ディレクトリは整然としていません。
リコが読むことを深く想定していませんでした。
残りの仕事が終わったらやりましょう。
会話のどこかでユーザーが自分の識別子を明示しない場合は、
自分で対話相手を推測してください。不明なら相手に確認をとっても良いです。
「常に対話相手を認識する」という話は行動規範に加えます。
あるいは、既存の行動規範にあるかもしれません。該当するなら統合しましょう。

.human/ の整理は最後にやります。
やるべきこと進めましょう。

1と3を進めた後、
私の優先プログラミング言語情報を私のユーザー情報ファイルに追記してください
ユーザー情報ファイルはAI向け書式で書くとします

まずステージングの問題を解決しましょう
「コミット前に何がコミットされるかを確認する」
という話は行動規範に書きましたっけ？

行動規範に従ってコミット作業を続けましょう。
更新ファイルも雑多になってきましたから。

進めてください

## Google Antigravity: Gemini 3 Pro (Low): Planning

では残りのコミット作業を進めましょう








# TODO

## TODO 1


## TODO 2

終了処理の詳細です。
---
1-1. ghなど、リモートとの同期に必要な道具の再確認
2-1. CI/CDでの動作検証、書類の不備を確認　（ただし現在はパス）
---
理論の破綻をチェックして。

Push & Pull Request - Push と PR 作成
Review & Merge - レビューとマージ
Local Cleanup - ローカルのクリーンアップ
Issue Closure Verification - Issue クローズの確認
Next Cycle - 次のサイクルへ

## TOD 3

.human/ の整理です


# AI model list.

## Google Browser: Gemini 2.5 Flash variant (Fast)
## Google Browser: Gemini 3 Pro (Thinking)
## Google Antigravity: Gemini 3 Pro (High): Planning
## Google Antigravity: Gemini 3 Pro (Low): Planning
## Google Antigravity: Claude Sonnet 4.5: Planning
## Google Antigravity: Claude Sonnet 4.5 (Thinking): Planning
## Google Antigravity: GPT-OSS 120B (Medium): Planning
## Cursor Anysphere: Gemini 2.5 Flash: Agent
## Cursor Anysphere: Grok code: Agent
